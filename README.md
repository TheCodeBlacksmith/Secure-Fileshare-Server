# Design:
## Overview:
Overall, the Secure Fileshare Server was designed to achieve all of the various functionalities intended with the least amount of code written as possible. This was primarily done in order for efficient debugging when it came to both functionality as well as security. To that end, repeated tasks were compartmentalized into helper methods that could be called when they needed to be done. For instance, each table within the database used for the 3S had respective methods which handled all queries to that table related to checking the existence of a row and in certain cases, delete those row(s). Similarly, cryptographic aspects of 3S related to login(), checkin(), checkout(), etc. were also written into individual methods in order to readily test these features and reuse them when necessary. 
## Database:
The implementation of the 3S necessitated having a persistent database. For this to be accomplished, the SQLite3 module was chosen. To abide by database best practices, the number of locations within the source code where a direct connection was made to the database was kept to the minimum amount. Namely, one method was called during the startup of the server to create the three tables used by the 3S while another method encapsulated all aspects of connecting to the database, executing a query with or without data regardless of the type of type of query (e.g. DELETE, INSERT, SELECT) and returning the resulting rows. In both methods, the connection to the database only lasted within the lifespan of that method’s execution and the connection would be safely terminated regardless of any SQLite3 or other exception occurring during the execution thanks to exception handling.
As mentioned before the database consists of three tables. Namely, Active_Users, User_Documents, and Documents_Access_Grants. Active_Users was used to store information pertaining to active users which consisted of the user ID, the client they were logged in from, and the session token. This table allowed for queries pertaining to a user’s host client and session health. User_Documents was used to store information, specifically meta-data related to documents that the server was in possession of. This included information on the owner of the document, the current state of the document (e.g. checked-in, checked-out), as well as information necessary to maintain security such as the encrypted version of the AES key in the event the documents was stored with the Confidentiality security flag. Lastly, the Documents_Access_Grants maintained all grants pertaining to any documents listed within the User_Documents. This included the specific users (or 0 for all users) the grant was for, the associated access right, and the time of expiration for the grant.
Mutual Authentication
For mutual authentication to take place in the 3S, during login the client signs the statement with the user’s private key and the server will verify it using the user’s respective public key that it has stored. This was made possible using the pkcs1_15, RSA, and SHA256 modules. In the event the user is not verified on the server side, the client will terminate. However, if the user is verified then the user’s information received from the client via the post_request() utility including the newly generated session token on the server are stored within the Active_Users table. The secrets module was chosen to be utilized for the generation of the session token as it allows the generation of cryptographically strong pseudo-random numbers which can be used as tokens.

## Cryptography:
In order for the files to be stored securely, a security flag was provided by the user during the check-in the file denoting how the storage of the file on the server would take place. 
In the event the security flag indicated confidentiality, denoted by a “1”, AES-256-CTR encryption would take place to encrypt the file’s contents before being stored. This was made possible using the pyaes, pbkdf2 and PKCS1_v1_5 modules. For encryption to be possible, a key was necessary as well as an initialization vector (IV) which allowed for increased randomness during the encryption process. The IV was generated as a 256-bit integer number using the secrets module.  Once the key and IV were generated, the file’s content would be encrypted in the aforementioned e4ncryption scheme and stored. Subsequently, the key used, as per project documentation was also encrypted vias a dedicated function using the server’s public key and stored in the in the encrypted format within the User_Documents. During checkout the reverse of these steps would take place with the key being decrypted using another dedicated function and then using the IV, decrypt the file content before sending it back to the user.
In the event the security flag indicated integrity, denoted by a “2”, the content of the file would be singed using the server’s private key and stored in a separate file that was named the same as the original file except with an additional “_signed” added to it. During checkout, this the signature of the file is verified using the server’s public key and only if verification is a success does checkout of the file take place. 
## Implementation:
### Implementation Details:
Login() implementation:
For the user to be logged in, a statement is crafted including the client ID and user ID. Subsequently, the aforementioned steps under Mutual Authentication take place for the encryption of the statement on the client side, its verification on the server side, and if verified, the return of the verified response alongside the newly generated unique session token. If the user is new, their information is stored in the Active_Users table. In the event the user is currently relogging in via a different client, the previous row in the Active_Users table pertaining to this session is removed effectively indicating that the the session has been terminated as any subsequent requests of any kind are invalid and are ignored by the server thanks to verification of the session token before any further action is taken by the server for all tasks besides login(). If the verified response and session token is received by the client, then a prompt listing the various available requests to the server alongside their respective numbers is displayed which the user can choose from.
### Checkin() implementation:
If the user selects to check-in a file the file’s name and desired security flag for the file are requested to be entered. These values are checked for validity and a non-existent document or invalid security flag is informed to the user via the client and prevents further action. These initial steps also account for the possibility that the file is currently in the checkout folder in which case the file is moved (not copied) to the checkin folder before further processing using the shutil module. Next, the file content is read and sent alongside the document ID, the security flag, and session token using the post_request utility. 
On the server side the session is verified to be active using the session token by querying the Active_Users table. Next, the server checks if the file already exists. If it does not, the file content can begin to be processed for storage using a dedicated helper function called checkin_file(). Otherwise, the User_Documents table is queried to determine if the user is the owner of the file or a query is made to the Documents_Access_Grants to check if they at least have checkin access via a grant to the file. If either of these conditions fail, the server responds with a 702. Any other extraneous circumstances by which further processing cannot occur such as an invalid session leads to a server response of 700. However, if the user does have the right to checkin the file, execution moves to checkin_file(). Here, based on the security flag processing of the file content as described under Secure File Storage – Cryptography takes place and the file is stored and relevant information about the data that was provided in the client request is stored in the User_Documents table. Subsequently the 200 response is sent by the server to the client at which point the file is removed from the latter’s checkin folder.
### Checkout() implementation:
If the user selects to check-out a file the file’s name is requested to be entered. This is then sent alongside the session token to the server via the post_request utility. 
On the server side the session is verified to be active using the session token by querying the Active_Users table. Next, the server checks if the file already exists. If it does not, the server throws a 704 since the file is not on the server. Otherwise, the User_Documents table is queried to determine if the user is the owner of the file or a query is made to the Documents_Access_Grants to check if they at least have checkout access via a grant to the file. If either of these conditions fail, the server responds with a 702. If checkout access is not found then a 702 is sent back by the server. However, if the user does have the right to check out the file, execution moves to checkout_file(). Here, based on the security flag found for the respective document in the User_Documents table, the file is decrypted or verified for Confidentiality or Integrity as described under Secure File Storage – Cryptography and then returned to the user. In the event any issue occurs during this decryption, 703 for broken integrity is sent back. Note that this implementation assumed any potential exception during decryption under the Confidentiality security flag, such as a file not found error would indicate that the server was compromised, or in other words, highlight a server integrity issue as the file should be there, leading to the same server response in that case. If all processing is successful the singed variant of the file, if it exists (only for security flag being Integrity), is removed since it will not be reused again and a copy of the file contents are sent back in a server response that has a status code of 200. The file contents are then sent to a file inside the checkout folder on the client side.


###  Grant() implementation:
If the user selects to add a grant to the list of grants in the Documents_Access_Grants table, then the client prompts the user to add the file’s documents ID, the targeted users for the grant, the access right, the number of seconds for the grant to last. This is all sent using the post_request utility alongside the session token. Note that there is a check to make sure that the amount of time entered is greater then 0.
On the server side, the session is validated to be still active. The server then checks if the file exists and then if the user who has made the request to add a grant is the owner of the file. If all of these checks pass, code execution moves to add_grant(), a helper method which processes all of the inputs by the user via the client, clears any old grants for the file that are no longer valid and then adds the new grant. If this procedure finishes successfully, the client receives the response with the status code 200.
###  Delete() implementation:
If the user selects to delete a file on the server, they are prompted to enter the file’s document id and this is sent with the session id to the server.
On the server side, the session is validated to be still active. The server then checks if the file exists and then if the user who has made the request to add a grant is the owner of the file. If all of these checks pass, code execution moves to delete_file(), a helper method which takes the steps to delete the file completely. It checks the security flag of the document in its meta data to determine if it just needs to delete the file or its signed version as well. It also subsequently deletes the document’s meta-data from the Documents_Access_Grants table and any associated grants of that file in the User_Documents table. If this procedure finishes successfully, the client receives the response with the status code 200.
### Logout() implementation:
When the user selects to logout the client begins going through all files in the client checkin and checkout folder. All modified files are passed through the checkin method. Note that the checkin method is able to accept the document id and security flag as method parameters which is used in this specific case only by running checkin() on files in the checkin and checkout folder with the security flag set to 2 (Integrity). Once completed, the session id is sent using the post_request utility to the server.
On the server side, the server checks that the session is active. If the session is found active then the server will respond with a status code of 200, otherwise 700.
Returning back to the client-side execution, as a final check to make sure the client is in a clean slate mode for the next user that logs in, any residual files are cleared in the checkin and checkout folders are cleared and then the client exits.

## Threats:
###  Threat Modelling:
In terms of threat agents, the most likely are individuals who wanted to access documents that they were not allowed to. Of course, for the sake of the project the server and clients were on the same OS although in a realistic setup these would be on separate infrastructure and the malicious users would not be able to simply open the database and edit it.
In a real-world setup of the 3S project as described above, the impact of potential breach would on the content of the documents. If the documents contain highly confidential information such as SSN, credit card numbers then the impact would be severe. However, for this project the contents of the documents were not critical and simply had random test the impact of a breach of integrity or confidentiality would not be as severe.
In terms of likelihood, these attacks would be highly possible in a real-world environment. Of course, these depend on several factors such as the ease with which the attack can be carried out and the associated reward with such an attack. For the current local setup of the project the likelihood is low and the associated reward as well. That said, as discussed earlier a real-world setting would have the documents contain more valuable information which would be more appealing and with the current implementation of the 3S, barring any additional security measures like two-factor authentication, password-hardening, etc. would be relatively easy to attack.
To that end, various controls (viz. safe guards and countermeasures) were added. For instance, requests to the server are set to default deny for any request access as the variable that indicates if the request can be accepted is set to fail by default and will only be set to True if all validation processes complete successfully. Additionally, sessions are completely removed upon the user logging out and the session token is validated at the start of each request. Furthermore, to prevent resource leaks access to such resources which in the case of the 3S was access to the database are restricted to specific functions which clean up any connections prior to database results being returned to the user. 
Based on the design of the 3S, the architecture effectively has several trust boundaries. Namely, the part where data from the user via the client is passed to the server can be seen as one such boundary and since a database is interacted with as well, there is also a trust boundary between it and the server. While this project is isolated to a single OS, these trust boundaries would major causes for concern in a real-world implementation of the 3S as these points would be the primary vectors through which attacks would try to take place.
### Threats Accounted For:
Based on the design of the Secure Fileshare Server, the server consistently requires interaction with the associated database in order to retrieve and update information about users and documents. Consequently, there is the possibility of threats related to that such as SQL injection attacks. In order account for this type of attack the SQL query construction was hardcoded so that this aspect was not in control of the users and users only provided the data arguments which, by passing through the cursor command, the data was made safe for database interaction (see python dos: https://docs.python.org/2/library/sqlite3.html). Additionally, the table construction was also done upon the start of the server and had no input from users. 
In addition, another major cause for concern is when inputs are erroneous which can confuse a program. To that end, input validation was done where necessary. For instance, in checkin() the existence of the file and the validity of the security flag is checked prior to the contents being sent to the server.
The server must also make sure it knows who it is talking to and for this reason during login, the user provides a statement that is encrypted during transit and decrypted on the server side and verified before the user is logged in. Other mitigations have been already listed under controls within the Threat Modelling section.
